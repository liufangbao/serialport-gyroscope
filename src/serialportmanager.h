#ifndef SERIALPORTMANAGER_H
#define SERIALPORTMANAGER_H
#include <QString>
#include <QTimer>
#include "qextserialport/qextserialport.h"
#include "qextserialport/qextserialenumerator.h"

#include <QString>

typedef quint32 uint32_t;
typedef quint16 uint16_t;
typedef quint8 uint8_t;

typedef void * xQueueHandle;
#define PIOS_STATIC_ASSERT(test) ((void)sizeof(int[1 - 2 * !(test)]))

#define UAVOBJ_ALL_INSTANCES                   0xFFFF
#define UAVOBJ_MAX_INSTANCES                   1000

/*
 * Shifts and masks used to read/write metadata flags.
 */
#define UAVOBJ_ACCESS_SHIFT                    0
#define UAVOBJ_GCS_ACCESS_SHIFT                1
#define UAVOBJ_TELEMETRY_ACKED_SHIFT           2
#define UAVOBJ_GCS_TELEMETRY_ACKED_SHIFT       3
#define UAVOBJ_TELEMETRY_UPDATE_MODE_SHIFT     4
#define UAVOBJ_GCS_TELEMETRY_UPDATE_MODE_SHIFT 6
#define UAVOBJ_LOGGING_UPDATE_MODE_SHIFT       8
#define UAVOBJ_UPDATE_MODE_MASK                0x3

typedef void *UAVObjHandle;

#define MetaObjectId(id) ((id) + 1)

/**
 * helper macro to access multi-element fields as array
 */
#define UAVObjectFieldToArray(type, var) \
    (*({ type *const dummy = &(var); \
         &(((type##Array *)dummy)->array); } \
       ))

// we have limited trust in our compiler
// make sure this macro actually works on all platforms

typedef struct __attribute__((__packed__)) {
    uint16_t element1;
    uint16_t element2;
    uint16_t element3;
}
__DummyUAVObjectFieldData;

typedef struct __attribute__((__packed__)) {
    uint16_t array[3];
}
__DummyUAVObjectFieldDataArray;

#define __DummyTA(var) UAVObjectFieldToArray(__DummyUAVObjectFieldData, var)

__attribute__((unused)) static void __DummyTAtest(void)
{
    __DummyUAVObjectFieldData t;

    PIOS_STATIC_ASSERT(sizeof(t) == sizeof(__DummyTA(t)));
    PIOS_STATIC_ASSERT(sizeof(t.element1) == sizeof(__DummyTA(t)[0]));
    PIOS_STATIC_ASSERT((void *)&t == (void *)&__DummyTA(t));
    PIOS_STATIC_ASSERT((void *)&t.element1 == (void *)&__DummyTA(t)[0]);
    PIOS_STATIC_ASSERT((void *)&t.element2 == (void *)&__DummyTA(t)[1]);
    PIOS_STATIC_ASSERT((void *)&t.element3 == (void *)&__DummyTA(t)[2]);
}

/**
 * Object update mode, used by multiple modules (e.g. telemetry and logger)
 */
typedef enum {
    UPDATEMODE_MANUAL    = 0, /** Manually update object, by calling the updated() function */
    UPDATEMODE_PERIODIC  = 1, /** Automatically update object at periodic intervals */
    UPDATEMODE_ONCHANGE  = 2, /** Only update object when its data changes */
    UPDATEMODE_THROTTLED = 3 /** Object is updated on change, but not more often than the interval time */
} UAVObjUpdateMode;

/**
 * Object metadata, each object has a meta object that holds its metadata. The metadata define
 * properties for each object and can be used by multiple modules (e.g. telemetry and logger)
 *
 * The object metadata flags are packed into a single 16 bit integer.
 * The bits in the flag field are defined as:
 *
 *   Bit(s)  Name                     Meaning
 *   ------  ----                     -------
 *      0    access                   Defines the access level for the local transactions (readonly=1 and readwrite=0)
 *      1    gcsAccess                Defines the access level for the local GCS transactions (readonly=1 and readwrite=0), not used in the flight s/w
 *      2    telemetryAcked           Defines if an ack is required for the transactions of this object (1:acked, 0:not acked)
 *      3    gcsTelemetryAcked        Defines if an ack is required for the transactions of this object (1:acked, 0:not acked)
 *    4-5    telemetryUpdateMode      Update mode used by the telemetry module (UAVObjUpdateMode)
 *    6-7    gcsTelemetryUpdateMode   Update mode used by the GCS (UAVObjUpdateMode)
 *    8-9    loggingUpdateMode        Update mode used by the logging module (UAVObjUpdateMode)
 */
typedef struct {
    uint16_t flags; /** Defines flags for update and logging modes and whether an update should be ACK'd (bits defined above) */
    uint16_t telemetryUpdatePeriod; /** Update period used by the telemetry module (only if telemetry mode is PERIODIC) */
    uint16_t gcsTelemetryUpdatePeriod; /** Update period used by the GCS (only if telemetry mode is PERIODIC) */
    uint16_t loggingUpdatePeriod; /** Update period used by the logging module (only if logging mode is PERIODIC) */
} __attribute__((packed)) UAVObjMetadata;

/**
 * Event types generated by the objects.
 */
typedef enum {
    EV_NONE     = 0x00, /** No event */
    EV_UNPACKED = 0x01, /** Object data updated by unpacking */
    EV_UPDATED  = 0x02, /** Object data updated by changing the data structure */
    EV_UPDATED_MANUAL   = 0x04, /** Object update event manually generated */
    EV_UPDATED_PERIODIC = 0x08, /** Object update from periodic event */
    EV_LOGGING_MANUAL   = 0x10, /** Object update event manually generated */
    EV_LOGGING_PERIODIC = 0x20, /** Object update from periodic event */
    EV_UPDATE_REQ = 0x40 /** Request to update object data */
} UAVObjEventType;

/**
 * Helper macros for event masks
 */
#define EV_MASK_ALL         0
#define EV_MASK_ALL_UPDATES (EV_UNPACKED | EV_UPDATED | EV_UPDATED_MANUAL | EV_UPDATED_PERIODIC | EV_LOGGING_MANUAL | EV_LOGGING_PERIODIC)

/**
 * Access types
 */
typedef enum {
    ACCESS_READWRITE = 0,
    ACCESS_READONLY  = 1
} UAVObjAccessType;

/**
 * Event message, this structure is sent in the event queue each time an event is generated
 */
typedef struct {
    UAVObjHandle    obj;
    uint16_t        instId;
    UAVObjEventType event;
    bool lowPriority; /* if true prevents raising warnings */
} UAVObjEvent;

/**
 * Event callback, this function is called when an event is invoked. The function
 * will be executed in the event task. The ev parameter should be copied if needed
 * after the function returns.
 */
typedef void (*UAVObjEventCallback)(UAVObjEvent *ev);

/**
 * Callback used to initialize the object fields to their default values.
 */
typedef void (*UAVObjInitializeCallback)(UAVObjHandle obj_handle, uint16_t instId);

/**
 * Event manager statistics
 */
typedef struct {
    uint32_t eventQueueErrors;
    uint32_t eventCallbackErrors;
    uint32_t lastCallbackErrorID;
    uint32_t lastQueueErrorID;
} UAVObjStats;

int32_t UAVObjInitialize();
void UAVObjGetStats(UAVObjStats *statsOut);
void UAVObjClearStats();
UAVObjHandle UAVObjRegister(uint32_t id, bool isSingleInstance, bool isSettings, bool isPriority, uint32_t num_bytes, UAVObjInitializeCallback initCb);
UAVObjHandle UAVObjGetByID(uint32_t id);
uint32_t UAVObjGetID(UAVObjHandle obj);
uint32_t UAVObjGetNumBytes(UAVObjHandle obj);
uint16_t UAVObjGetNumInstances(UAVObjHandle obj);
UAVObjHandle UAVObjGetLinkedObj(UAVObjHandle obj);
uint16_t UAVObjCreateInstance(UAVObjHandle obj_handle, UAVObjInitializeCallback initCb);
bool UAVObjIsSingleInstance(UAVObjHandle obj);
bool UAVObjIsMetaobject(UAVObjHandle obj);
bool UAVObjIsSettings(UAVObjHandle obj);
bool UAVObjIsPriority(UAVObjHandle obj);
int32_t UAVObjUnpack(UAVObjHandle obj_handle, uint16_t instId, const uint8_t *dataIn);
int32_t UAVObjPack(UAVObjHandle obj_handle, uint16_t instId, uint8_t *dataOut);
uint8_t UAVObjUpdateCRC(UAVObjHandle obj_handle, uint16_t instId, uint8_t crc);
int32_t UAVObjSave(UAVObjHandle obj_handle, uint16_t instId);
int32_t UAVObjLoad(UAVObjHandle obj_handle, uint16_t instId);
int32_t UAVObjDelete(UAVObjHandle obj_handle, uint16_t instId);
int32_t UAVObjSaveSettings();
int32_t UAVObjLoadSettings();
int32_t UAVObjDeleteSettings();
int32_t UAVObjSaveMetaobjects();
int32_t UAVObjLoadMetaobjects();
int32_t UAVObjDeleteMetaobjects();
int32_t UAVObjSetData(UAVObjHandle obj_handle, const void *dataIn);
int32_t UAVObjSetDataField(UAVObjHandle obj_handle, const void *dataIn, uint32_t offset, uint32_t size);
int32_t UAVObjGetData(UAVObjHandle obj_handle, void *dataOut);
int32_t UAVObjGetDataField(UAVObjHandle obj_handle, void *dataOut, uint32_t offset, uint32_t size);
int32_t UAVObjSetInstanceData(UAVObjHandle obj_handle, uint16_t instId, const void *dataIn);
int32_t UAVObjSetInstanceDataField(UAVObjHandle obj_handle, uint16_t instId, const void *dataIn, uint32_t offset, uint32_t size);
int32_t UAVObjGetInstanceData(UAVObjHandle obj_handle, uint16_t instId, void *dataOut);
int32_t UAVObjGetInstanceDataField(UAVObjHandle obj_handle, uint16_t instId, void *dataOut, uint32_t offset, uint32_t size);
int32_t UAVObjSetMetadata(UAVObjHandle obj_handle, const UAVObjMetadata *dataIn);
int32_t UAVObjGetMetadata(UAVObjHandle obj_handle, UAVObjMetadata *dataOut);
uint8_t UAVObjGetMetadataAccess(const UAVObjMetadata *dataOut);
UAVObjAccessType UAVObjGetAccess(const UAVObjMetadata *dataOut);
void UAVObjSetAccess(UAVObjMetadata *dataOut, UAVObjAccessType mode);
UAVObjAccessType UAVObjGetGcsAccess(const UAVObjMetadata *dataOut);
void UAVObjSetGcsAccess(UAVObjMetadata *dataOut, UAVObjAccessType mode);
uint8_t UAVObjGetTelemetryAcked(const UAVObjMetadata *dataOut);
void UAVObjSetTelemetryAcked(UAVObjMetadata *dataOut, uint8_t val);
uint8_t UAVObjGetGcsTelemetryAcked(const UAVObjMetadata *dataOut);
void UAVObjSetGcsTelemetryAcked(UAVObjMetadata *dataOut, uint8_t val);
UAVObjUpdateMode UAVObjGetTelemetryUpdateMode(const UAVObjMetadata *dataOut);
void UAVObjSetTelemetryUpdateMode(UAVObjMetadata *dataOut, UAVObjUpdateMode val);
UAVObjUpdateMode UAVObjGetGcsTelemetryUpdateMode(const UAVObjMetadata *dataOut);
void UAVObjSetTelemetryGcsUpdateMode(UAVObjMetadata *dataOut, UAVObjUpdateMode val);
UAVObjUpdateMode UAVObjGetLoggingUpdateMode(const UAVObjMetadata *dataOut);
void UAVObjSetLoggingUpdateMode(UAVObjMetadata *dataOut, UAVObjUpdateMode val);
int8_t UAVObjReadOnly(UAVObjHandle obj);
int32_t UAVObjConnectQueue(UAVObjHandle obj_handle, xQueueHandle queue, uint8_t eventMask);
int32_t UAVObjDisconnectQueue(UAVObjHandle obj_handle, xQueueHandle queue);
int32_t UAVObjConnectCallback(UAVObjHandle obj_handle, UAVObjEventCallback cb, uint8_t eventMask);
int32_t UAVObjDisconnectCallback(UAVObjHandle obj_handle, UAVObjEventCallback cb);
void UAVObjRequestUpdate(UAVObjHandle obj);
void UAVObjRequestInstanceUpdate(UAVObjHandle obj_handle, uint16_t instId);
void UAVObjUpdated(UAVObjHandle obj);
void UAVObjInstanceUpdated(UAVObjHandle obj_handle, uint16_t instId);
void UAVObjLogging(UAVObjHandle obj);
void UAVObjInstanceLogging(UAVObjHandle obj_handle, uint16_t instId);
void UAVObjIterate(void (*iterator)(UAVObjHandle obj));
void UAVObjInstanceWriteToLog(UAVObjHandle obj_handle, uint16_t instId);

/*
   how to generate include as following:
   cd src/flight
   sudo grep "_OBJID" -R *.h |awk -F : '{print "#include\"flight/"$1"\""}' >$PWD/../ObjIdIncludeList
   cp ObjIdIncludeList HERE
*/
#include"flight/accelgyrosettings.h"
#include"flight/accelsensor.h"
#include"flight/accelstate.h"
#include"flight/accessorydesired.h"
#include"flight/actuatorcommand.h"
#include"flight/actuatordesired.h"
#include"flight/actuatorsettings.h"
#include"flight/airspeedsensor.h"
#include"flight/airspeedsettings.h"
#include"flight/airspeedstate.h"
#include"flight/altitudefiltersettings.h"
#include"flight/altitudeholdsettings.h"
#include"flight/altitudeholdstatus.h"
#include"flight/attitudesettings.h"
#include"flight/attitudesimulated.h"
#include"flight/attitudestate.h"
#include"flight/auxmagsensor.h"
#include"flight/auxmagsettings.h"
#include"flight/barosensor.h"
#include"flight/callbackinfo.h"
#include"flight/cameradesired.h"
#include"flight/camerastabsettings.h"
#include"flight/debuglogcontrol.h"
#include"flight/debuglogentry.h"
#include"flight/debuglogsettings.h"
#include"flight/debuglogstatus.h"
#include"flight/ekfconfiguration.h"
#include"flight/ekfstatevariance.h"
#include"flight/faultsettings.h"
#include"flight/firmwareiapobj.h"
#include"flight/fixedwingpathfollowersettings.h"
#include"flight/fixedwingpathfollowerstatus.h"
#include"flight/flightbatterysettings.h"
#include"flight/flightbatterystate.h"
#include"flight/flightmodesettings.h"
#include"flight/flightplancontrol.h"
#include"flight/flightplansettings.h"
#include"flight/flightplanstatus.h"
#include"flight/flightstatus.h"
#include"flight/flighttelemetrystats.h"
#include"flight/gcsreceiver.h"
#include"flight/gcstelemetrystats.h"
#include"flight/gpsextendedstatus.h"
#include"flight/gpspositionsensor.h"
#include"flight/gpssatellites.h"
#include"flight/gpssettings.h"
#include"flight/gpstime.h"
#include"flight/gpsvelocitysensor.h"
#include"flight/groundtruth.h"
#include"flight/gyrosensor.h"
#include"flight/gyrostate.h"
#include"flight/homelocation.h"
#include"flight/hwsettings.h"
#include"flight/i2cstats.h"
#include"flight/magsensor.h"
#include"flight/magstate.h"
#include"flight/manualcontrolcommand.h"
#include"flight/manualcontrolsettings.h"
#include"flight/mixersettings.h"
#include"flight/mixerstatus.h"
#include"flight/mpu6000settings.h"
#include"flight/nedaccel.h"
#include"flight/objectpersistence.h"
#include"flight/oplinkreceiver.h"
#include"flight/oplinksettings.h"
#include"flight/oplinkstatus.h"
#include"flight/osdsettings.h"
#include"flight/overosyncsettings.h"
#include"flight/overosyncstats.h"
#include"flight/pathaction.h"
#include"flight/pathdesired.h"
#include"flight/pathplan.h"
#include"flight/pathstatus.h"
#include"flight/pathsummary.h"
#include"flight/perfcounter.h"
#include"flight/poilearnsettings.h"
#include"flight/poilocation.h"
#include"flight/positionstate.h"
#include"flight/radiocombridgestats.h"
#include"flight/ratedesired.h"
#include"flight/receiveractivity.h"
#include"flight/revocalibration.h"
#include"flight/revosettings.h"
#include"flight/sonaraltitude.h"
#include"flight/stabilizationbank.h"
#include"flight/stabilizationdesired.h"
#include"flight/stabilizationsettingsbank1.h"
#include"flight/stabilizationsettingsbank2.h"
#include"flight/stabilizationsettingsbank3.h"
#include"flight/stabilizationsettings.h"
#include"flight/stabilizationstatus.h"
#include"flight/systemalarms.h"
#include"flight/systemsettings.h"
#include"flight/systemstats.h"
#include"flight/takeofflocation.h"
#include"flight/taskinfo.h"
#include"flight/txpidsettings.h"
#include"flight/velocitydesired.h"
#include"flight/velocitystate.h"
#include"flight/vtolpathfollowersettings.h"
#include"flight/vtolselftuningstats.h"
#include"flight/watchdogstatus.h"
#include"flight/waypointactive.h"
#include"flight/waypoint.h"


// Private types and constants

// min header : sync(1), type (1), size(2), object ID(4), instance ID(2)
#define UAVTALK_MIN_HEADER_LENGTH  10

// max header : sync(1), type (1), size(2), object ID(4), instance ID(2), timestamp(2)
#define UAVTALK_MAX_HEADER_LENGTH  12

#define UAVTALK_CHECKSUM_LENGTH    1
#define UAVOBJECTS_LARGEST 217
#define UAVTALK_MAX_PAYLOAD_LENGTH (UAVOBJECTS_LARGEST + 1)

#define UAVTALK_MIN_PACKET_LENGTH  UAVTALK_MAX_HEADER_LENGTH + UAVTALK_CHECKSUM_LENGTH
#define UAVTALK_MAX_PACKET_LENGTH  UAVTALK_MIN_PACKET_LENGTH + UAVTALK_MAX_PAYLOAD_LENGTH

#define UAVTALK_CANARI          0xCA
#define UAVTALK_SYNC_VAL        0x3C

#define UAVTALK_TYPE_MASK       0x78
#define UAVTALK_TYPE_VER        0x20
#define UAVTALK_TIMESTAMPED     0x80
#define UAVTALK_TYPE_OBJ        (UAVTALK_TYPE_VER | 0x00)
#define UAVTALK_TYPE_OBJ_REQ    (UAVTALK_TYPE_VER | 0x01)
#define UAVTALK_TYPE_OBJ_ACK    (UAVTALK_TYPE_VER | 0x02)
#define UAVTALK_TYPE_ACK        (UAVTALK_TYPE_VER | 0x03)
#define UAVTALK_TYPE_NACK       (UAVTALK_TYPE_VER | 0x04)
#define UAVTALK_TYPE_OBJ_TS     (UAVTALK_TIMESTAMPED | UAVTALK_TYPE_OBJ)
#define UAVTALK_TYPE_OBJ_ACK_TS (UAVTALK_TIMESTAMPED | UAVTALK_TYPE_OBJ_ACK)

typedef short int16_t;
typedef int int32_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;


class SerialPortManager: public QObject
{
    Q_OBJECT
    QTimer *mTimer;
    QString mPortName;
    PortSettings mSettings;
    QextSerialPort *mPort;
    QString mReceivedString;
    QByteArray mReceivedArray;
    typedef enum {
        UAVTALK_STATE_ERROR = 0,
                   UAVTALK_STATE_SYNC,
                   UAVTALK_STATE_TYPE,
                   UAVTALK_STATE_SIZE,
                   UAVTALK_STATE_OBJID,
                   UAVTALK_STATE_INSTID,
                   UAVTALK_STATE_TIMESTAMP,
                   UAVTALK_STATE_DATA,
                   UAVTALK_STATE_CS,
                   UAVTALK_STATE_COMPLETE
                 } UAVTalkRxState;

    typedef struct {
        uint8_t  type;
        uint16_t packet_size;
        uint32_t objId;
        uint16_t instId;
        uint32_t length;
        uint8_t  timestampLength;
        uint8_t  cs;
        uint16_t timestamp;
        uint32_t rxCount;
        UAVTalkRxState state;
        uint16_t rxPacketLength;
    } UAVTalkInputProcessor;

    UAVTalkInputProcessor *iproc;

    AccelStateData mAccelStateData;
    AttitudeStateDataPacked mAttitudeState;
    GCSTelemetryStatsDataPacked mGCSTelemetryStats;
    FlightTelemetryStatsData mFlightTelemetryStatsData;
    SystemStatsDataPacked mSystemStats;
    StabilizationDesiredData mStabilizationDesiredData;

    class UAVObjectHandler
    {
        QString mPacketName;
        uint32_t mObjId;
        uint32_t mPacketLength;
    public:
        UAVObjectHandler();
        UAVObjectHandler( uint32_t objId);
        QString getPacketName();
        uint32_t getObjId();
        uint32_t getPacketLength();
    };

public:
    SerialPortManager(QString *portName);
    uint8_t PIOS_CRC_updateByte(uint8_t crc, const uint8_t data);
    UAVTalkRxState UAVTalkProcessInputStreamQuiet(uint8_t rxbyte);
    QextSerialPort *port() const;

signals:
    void attitudeReady(float p,float r,float y);
public slots:
    void onReadyRead();

private slots:
    void handlePacket(uint32_t objId,QByteArray array);
};

#endif // SERIALPORTMANAGER_H
